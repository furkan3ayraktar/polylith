
- Show direct changes with an '*' per brick and a '*' in the
  "test column" if the brick is indirectly changed in that environment (and has
  a test folder) and that we therefore need to execute the tests. Show the asterisks
  in white so that they can be spotted more easily:
    interface      brick          cli  core  dev
    --------------------------------------------
    change         change         x-    x-   xx
    command        command        x-    --   xx
    common         common         x-    x-   xx
    deps           deps           x-    x-   xx
    file           file           x-    x-   xx
    git            git            x-    x-   x*
    help           help           x-    x-   xx
    shell          shell *        x-    x-   xx
    test-runner    test-runner    x-    --   xx
    text-table     text-table     x-    x-   xx
    util           util           x-    x-   xx
    validate       validate       x-    x-   xx
    workspace      workspace      x-    x-   xx
    workspace-clj  workspace-clj  x-    --   xx
    -              cli            x-    --   xx
    -              z-jocke        --    --   xx

- remove the SLF4J error when running the test command:
  "Failed to load class "org.slf4j.impl.StaticLoggerBinder".
  See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.

- experiment with implementing a git hook that if the workspace is valid, saves a workspace.edn
  at the root of the project and commits it before every push. Then we could "animate" over the
  changes of the system over time. It's important to store a :schema-version attribute of the
  workspace, to keep track of schema changes.

- show aliases in a separate table in the 'info' command where under the src
  column we show if it has its own 'src' and 'test' folder. If any brick in
  the environment is changed, then show an '*' after the environment name.
  If '-loc' is sent in as an argument, also show the number of lines of code
  it has in its 'src' and 'test' folder.
    environment  alias  src  loc  (t)
    ---------------------------------
    cli          cli    --     0    0
    core         core   xx     0    0
    dev *        dev    xx     0  243

- check why workspace-clj doesn't have any :definitions in its :interface.

- implement the 'deps' command.
  - When typing "deps env brick", show the dependencies of the brick within the given environment.
    If a component is not yet added to the environment, show the interface under 'uses':
    used-by > brick > uses
    -------           ----------
    command           common
    cli               deps
    z-jocke           file
                      text-table
                      util
                      validate
  - when typing "deps env" then show all dependencies for the given environment.
    If a component is not yet added to the environment, show interface in the column instead:
                                                        w
                                                        o
                                         t              r
                                         e              k
                                         s  t        w  s
                                         t  e     v  o  p
                    c                    -  x     a  r  a
                 c  o  c                 r  t     l  k  c
                 h  m  o              s  u  -     i  s  e
                 a  m  m  d  f     h  h  n  t  u  d  p  -
                 n  a  m  e  i  g  l  e  n  b  t  a  a  c
                 g  n  o  p  l  i  e  l  e  l  i  t  c  l
 brick           e  d  n  s  e  t  p  l  r  e  l  e  e  j
 --------------------------------------------------------
 change          ·  ·  ·  ·  ·  x  ·  ·  ·  ·  x  ·  ·  ·
 command         ·  ·  x  ·  ·  ·  x  ·  x  ·  x  ·  x  ·
 common          ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  x  ·  ·  ·
 deps            ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 file            ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 git             ·  ·  ·  ·  ·  ·  ·  x  ·  ·  ·  ·  ·  ·
 help            ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 shell           ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 test-runner     ·  ·  x  ·  x  ·  ·  ·  ·  ·  x  ·  ·  ·
 text-table      ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  x  ·  ·  ·
 util            ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 validate        ·  ·  x  x  ·  ·  ·  ·  ·  ·  x  ·  ·  ·
 workspace       ·  ·  x  x  x  ·  ·  ·  ·  x  x  x  ·  ·
 workspace-clj   ·  ·  x  ·  x  ·  ·  ·  ·  ·  x  ·  ·  ·
 cli             x  x  ·  ·  x  ·  ·  ·  ·  ·  ·  ·  x  x
 z-jocke         ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  x  ·  x  x


- show a more user friendly error if deps.edn is missing at the root.
- show a better error if :color-mode is not set in deps.edn.

- calculate :run-tests-for attribute to each environment. Right now we only base
  that list of bricks on what bricks that are included in the tests for that
  environment.

- add a warning if not a valid directory (interface) could be found for a brick
  directly after the top namespace directory path (see str-util/skip-until).

- workspace-clj > changes > workspace.

- add support for -ns in the 'info' command that lists two extra columns '#ns' and
  'loc/ns'. '-all' will perform both '-loc' and '#ns'.

- show warnings if the same unit test exists in more than one environment.

- use :file-extensions from :src-reader.
- use :slash from :src-reader

- check if the 'cli' environment can depende on the core jar instead
  and remove all bricks except three of them.

- extract workspace-clj/namespace/top-src-dirs to its own 'namespace'
  component and expose it in the core API.

- create a spec that checks a workspace + expose it in the core API.

- when a workspace is enhanced, also set :vcs to "git".

- make the thousand seperator be configurable, so that we can e.g. print out
  2340 as any of these (default is ""): 2340 2,340 2.340

- add validation that detects if no component was found for an interface.

- make sure we only have one interface defined per component.

- fix the error that occurres when having an invalid test src folder, e.g.
  "../../components/z-jocketest".

- if an environment misses a component, show it correctly in the 'info' command
  as a yellow "i" in each environment.

- check how 'info' handles circular dependencies.

- put back the 'spec' component and make sure we have the :polylith section with
  an entry for :top-namespace + if color-mode is specifiec that it has valid values.

- make sure we don't throw exception if we type a command from a
  directory that has no deps.edn.

- have a look at the kotlin embedded library again.

- create a githook that verifies the project.

- check that we follow symbolic links in file/paths-recursively.

- add the LICENSE to the root.

- only include the corresponding test-environment if the :aliases {:test ...}}
  key is defined in deps.edn.

- in the 'cli' environment, depend on the core jar instead of real components.
  - maybe we need two variants:
    - polylith-clj-core
    - polylith-clj-core-aot

- add support for reading files from git and maybe http url:s.

- make sure we handle imported namespaces in a generic way, right now we assume
  that they are separated with a "." in deps.dependencies/brick-namespace.

- just add more attributes to what e.g. workspace-clj adds, so that
  a tool creator can decide to add whatever attributes they need
  to perform the 'test' and 'build' commands.

- think of a solution where we send in 'none' as color-mode instead of
  forcing us to calculate both colorized-message and message in the 'validate' component.

- add the 'version' command.

- add a 'deps' command that could show what components it uses
  and what bricks uses it in each environment.

- add tasks (arguments to the 'poly' command)':
  - ws
    - view the workspace map.
    - support returning JSON.
      - configured in deps.edn
      - stored in a config file in ~/.polylith
    - possibility to send in sha1 and sha2 or only sha1.
  - build
    - build a simple jar

- only run tests that has changed (directly or indirectly).
  {:changes {:changed-bricks []
             :changed-environments []}
             :changed-bricks-indirectly []
             :changed-environments-indirectly []}}}

Questions
=========
- can I delete .gradle from the project root?
- it's really great that integration tests can be put in each environment, but where
  to put system level end-to-end tests?
- how can we have a build that first builds polylith.clj.core and then builds
  polylith.core and deploys it to clojars?
- we don't get nice error messages when running tests through tools.deps, e.g when
  a namespace can't be imported or if a component is missing so it can't compile.
- :color-mode should be per developer, not per workspace. Put it in .polylith/config.edn?
- polylith.workspace-clj.namespaces-from-disk/->namespace
- check if we should register for https://github.com/sponsors.

Leave for now
=============
- extract the doc for each function (metadata).
- when releasing:
  - make sure we have all the documentation in place.
  - it would be good if the tool that can migrate old lein-polylith projects were in place.
  - update realworld repo, make it the default in the realworld repository.
  - update the documentation in lein-polylith and tell that we have a new brand
    tool that builds on top of tools.deps.
  - update the :ws-reader/:project-url to point to master
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- figure out what jar:s are missing based on the imports.
- if building a UI, then we need to calculate this data based on :interface-deps:
  - uses-directly (interface + component per environment)
  - uses-indirectly
  - used-by-directly
  - used-by-indirectly
- in the UI, show the missing interface dependencies as interfaces
  in the environment column that contains the components.
- in the UI, when you click on a component or base, show what components
  it uses (directly or indirectly) in every environement + what components
  that uses it (directly or indirectly). If both thing happens at the same time,
  then we have circular dependencies!
- make sure we can compile the code into a command line tool using GraalVM.



Doc
===
- people sometimes ask for sub-components, but in polylith you instead divide
  your component in namespaces and sub namespaces to achieve the same thing.
- tips on how to do destructuring in the interface.
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.
- some extra benefits of using interfaces:
  - in the implementing namespace(s) the functions must be defined in the
    right order, but in the interface they can e.g. be listed in alphabetic order.
  - in the implementing namespace(s) the arguments can sometimes be destructured
    directly so that it's not obvious what "type" (map) it is, but in the interface
    we can keep a good name of each argument.
  - functions can be overloaded in the interface but have just one function
    signature in the implementing namespace where arguments can be nil.
  - if we use destructuring in the implementation, we can keep the original names
    in the interface for increased readability (it can be easier to understand if the
    parameter is e.g. 'user' in the interface instead of a list of destructured values.

Differences compared to lein-polylith
=====================================
- support for type hints as part of the function signature of functions.
- easier to build libraries and toolings around polylith by using the polylith-core library.
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- simpler and less "intrusive":
  - no symbolic links
  - only environments, not both services and environments as in lein-polylith.
  - no empty workspace interfaces.
  - code can easily be added manually and no need for 'create' and 'delete' commands.
  - changes are handled entirely by git, not by both git and via file timestamps.
  - no 'sync' command needed.
- more powerful:
  - supports multiple environments
  - supports having tests per environment
  - faster. No need for a 'prompt' command. The 'check' command runs in about a second.
  - advanced 'info' command with cupport for colors.
  - improved error messages.
  - an environment can have a different version of a library than other environments.
- improved visualisation with tables and colors.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

Commands
========
./make-uberjar.sh dev polylith.clj.core.cli.poly
sudo cp ./environments/core/target/core.jar /usr/local/polylith/poly.jar

polylith:  clj -A:dev:test
realworld: clj -A:polylith:test