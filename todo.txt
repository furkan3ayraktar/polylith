
- calculate changes
  - run the 'git diff' command:
    - if no arguments, use HEAD.
    - if one argument, diff against local changes
    - if two arguments, diff against the two hashes.
  - read all :require statements
  - calculate dependencies (to 'component/interface' namespace).

- use sorted set for interface-names + remove explicit set commands.

- support both .clj and .cljc files.

- use only the prefix :env and :env.test in profiles, stop using :service
  and :service.test as now. :env.test would be test environments.
  Also support :env.prod and averything that starts with ":env.".

- check that we handle all corner cases when reading code (check lein-polylith).

- make sure we can compile the code into a command line tool using GraalVM.

- replace \ with / at the entry point:
  (str/replace top-ns #"\." "/")

- to support other languages, each parameter also needs so handle the type.

- support migrating lein-polylith projects to deps.edn projects.

- eventually: create a migration tool that migrates lein-polylith projects to
  polylith projects.

Questions
=========
- make sub namespaces to 'interface' be bart of the contract, e.g. interface.spec.
- it looks like 'build-tool' in the realworld project is not a component,
  at least it has no interface.
- should the name of a command line tool be 'poly'?
- should we allow to have a function in one component and a macro in another
  if the function/macro looks exactly the same, e.g.: unless[pred a b].
  - maybe not, because a fanction can be used as a value, like an argument to
    a function, but a macro can't.
- store the environment definitions of :aliases as :environments?
  - store the reset of the aliases as something generic?
- only functions in interface.clj is part of the contract, but we allow dependencies
  to e.g. interface.spec which will show up as a dependency.

Doc
===
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- a function can't be used as an implememtor of a macro in two different components
  and vice versa.

Differences compared to lein-polylith
=====================================
- each service can have its own version of a library, so that service A has
  version 1.1 of a library, but service B has 1.2 and the development
  environment has 1.3.

Design decisions
================
- To be able to reload a whole comonent in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of function in the namespace.
