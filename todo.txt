
- add the list of diff:ed files to :changes.

- rename :imports in each brick to :namespaces.
- rename from :ns-path to :namespace + remove "brick/".

- calculate :lines-of-code in each entry in :imports.

- store each changed environment-group like e.g. this:
  - also, when calculating changes, only check for paths that are included in :paths,
    so that we only check 'test' directories for test environments and changes under
    the 'src' directory for the "main" environment.
  {:group "core"
   :src-changed? true
   :test-changed? false
   :changed-bricks ["file"]
   :indirectly-changed-bricks ["article"]
  }

- store :deps as strings (and not symbols) but remember to convert them back to
  symbols before use.

- store each message with its own attributes, e.g.:
  {:type "error"
   :code 101
   :message "Circular dependencies was found: article > profile > article"
   :bricks ["article" "profile"]}

- make sure we can compile the code into a command line tool using GraalVM.
- compile a 'poly' tool with GraalVM.


- add tasks (arguments to the 'poly' command)':
  - verify:
    - prints the messages
  - ws
    - view the workspace map.
    - support returning JSON.
      - configured in deps.edn
      - stored in a config file in ~/.polylith
  - change
    - show changes + return sha1 and sha2.
  - build
    - build a simple jar

- store extra information for each warning/error (e.g.):
  {:interface "payment"
   :component "payment"
   :definition {:name "pay", :type "function", :parameters ["a"] :sub-ns ""}
  }

- add error for the case that a namespace can't even be parsed.

- handle the case that a component doesn not exist any more in the 'diff'
  function, which especially can happen when seding in two SHA:s.

Questions
=========
- how should we calculate workspace changes?
  - include test environments?
- figure out a way to show the output while running the tests.

Leave for now
=============
- release the new tool + make it the default in the realworld repository +
  create a branch for the old lein-polylith code.
- create a githook that verifies the project.
- should the name of a command line tool be 'poly'?
- how to handle test dependencies?
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- how to decorate the errors and warnings so that a tool can easily mark what's
  wrong in a e.g. a UI.


Doc
===
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.

Differences compared to lein-polylith
=====================================
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- it is much faster.
- the new tool is simpler and you can e.g. add, rename and delete components manually
  without extra tooling.
- each service can have its own version of a library, so that service A has version 1.1
  of a library, but service B has 1.2 and the development environment has 1.3.
- we base changes on git, not on both git and timestamps. The reason is to make it
  simpler and that timestamps didn't work well with git.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.
