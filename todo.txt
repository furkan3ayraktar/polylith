
- show a forth x in the environment table (if tests will be executed of not).

- add profile related validations:
  - don't allow having components with an interface with more than one component
    in the development environment.
  - show a warning if a path exists in a dev profile and dev.
    - add :redundant-paths and :redundant-deps to :profile->settings.

- complain if trying to include a profile with e.g. +admin, that does not exists,
  except an empty one (just +) that will result in showing all profiles.

- complain if any of the given env:my-env was not found.

- remove :has-src-dir and :has-test-dir.

- check why the cli environment test folder didn't turn up in dev when running 'info'.

- create a .keep file in development/src when creating a workspace.

- also do util/stringify-and-sort-map for test-lib-deps in workspace-clj.
- add :test-lib-deps to bases.



- move print-table-str-keys + enrich-workspace-str-keys to java.core.

- store :top-namespace and :interface-ns as symbols in deps.edn, but as strings internally.

- implement 'deps :lib' as a separate table, e.g.:
                 l  l  l
                 i  i  i
                 b  b  b
                 -  -  -
                 1  2  3
    --------------------
    component1   x  x  -
    component2   -  x  x
    component3   x  -  -
    base1        -  x  -

    library                       version  cli  core  dev
    -----------------------------------------------------
    org.clojure/clojure           1.10.1    x    x     x
    org.clojure/tools.deps.alpha  0.8.695   x    x     x

- implement 'migrate' that migrates old lein-polylith projects.

  The :dev+dev could be the alias that is always included in different commands like
  'deps' and 'test' if not another config like +prod is given.

- add tests for the 'test' command.

- move polylith-kotlin to private repo.

- make sure Polylith works with Windows:
  - use configs from ./polylith/config.edn:
    - slash
    - line-separator

- update the help.
  - have separate help for the different 'create' variants + show in the overview.

- 'help' should not be part of core.

- let 'workspace' just assoc new attributes so that extra attributes that we don't know about
  will not dissappear.

- use :file-extensions from :src-reader.

- add support for reading files from git and maybe http url:s. One idea is to create a 'reader'
  component that can delegate to e.g. 'file-reader' and others.

- add the 'version' command.

- put back the 'spec' component and make sure we have the :polylith section with
  an entry for :top-namespace + if color-mode is specifiec that it has valid values.
  - create a spec that checks a workspace + expose it in the core API.

- set up the polylith github project:
  - so that people can report errors
  - activate CI

- also show the columns '#ns' and 'loc/ns' in the 'info' command when sending in -loc as argument.
  - change from '(t)' to 'loc-t' ?

- check if the 'cli' environment can depend on the core jar instead
  and remove all bricks except three of them.
  - in the 'cli' environment, depend on the core jar instead of real components.
    - maybe we need two variants:
      - polylith-clj-core
      - polylith-clj-core-aot

- let the output of 'ws' be nicely formatted and come in a logical order.

- let util.def-map handle attributes with namespace in it, e.g. [paths deps aliases mvn/repos]
  in environments-from-disk.

- check that we follow symbolic links in file/paths-recursively.


Questions
=========
- also show the profiles in the environments table.
- how to convert the git repo?
- check if we should register for https://github.com/sponsors.

Leave for now
=============
- maybe use clj-exec: https://insideclojure.org/2020/07/28/clj-exec/
- extract the doc for each function (metadata).
- when releasing:
  - make sure we have all the documentation in place.
  - update realworld repo, make it the default in the realworld repository.
  - update the documentation in lein-polylith and tell that we have a new brand
    tool that builds on top of tools.deps.
  - update the :ws-reader/:project-url to point to master
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- figure out what jar:s are missing based on the imports.
- if building a UI, then we need to calculate this data based on :interface-deps:
  - uses-directly (interface + component per environment)
  - uses-indirectly
  - used-by-directly
  - used-by-indirectly
- in the UI, show the missing interface dependencies as interfaces
  in the environment column that contains the components.
- in the UI, when you click on a component or base, show what components
  it uses (directly or indirectly) in every environement + what components
  that uses it (directly or indirectly). If both thing happens at the same time,
  then we have circular dependencies!
- make sure we can compile the code into a command line tool using GraalVM.
- add the feature "hide-succeeding-rows" to the text-table component that will show
  following lines as blank. Support having more than one column in a "group".
- make sure we handle imported namespaces in a generic way, right now we assume
  that they are separated with a "." in deps.dependencies/brick-namespace.
- show dependencies at the function level?
- maybe use clojure.tools.namespace.parse to get the dependencies to other namespaces.

Doc
===
- cursive tip, when deps.edn can't be parsed, you have to fix it and add it manually again.
- a components increases cohesion so that we can put all the code, tests, resources
  and documentation for that piece of code into one place, which increases changeability.
- show the colors I use for best contrasts + mention borealis.
- people sometimes ask for sub-components, but in polylith you instead divide
  your component in namespaces and sub namespaces to achieve the same thing.
- you don't need another abstraction, like UML diagrams, to communicate your high
  level design, because in polylith the workspace *is* your high level design!
- tips on how to do destructuring in the interface.
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.
- some extra benefits of using interfaces:
  - it's very clear what functions that can be accessed and setting things to private is
    not needed if delegating to implementing namespaces.
  - easier to test when functions in implementing namespaces can be kept public, because
    we already restrict access to other namespaces than the component interface.
  - the interface can keep the parameter name as is and only have destructuring in the implementation.
  - in the implementing namespace(s) the functions must be defined in the
    right order, but in the interface they can e.g. be listed in alphabetic order.
  - in the implementing namespace(s) the arguments can sometimes be destructured
    directly so that it's not obvious what "type" (map) it is, but in the interface
    we can keep a good name of each argument.
  - functions can be overloaded in the interface but have just one function
    signature in the implementing namespace where arguments can be nil.
  - if we use destructuring in the implementation, we can keep the original names
    in the interface for increased readability (it can be easier to understand if the
    parameter is e.g. 'user' in the interface instead of a list of destructured values.
  - refer to this code where we in a couple of places don't deletage to a core namespace
    and in another (validate) mostly delegate, but keep things in the interface.
- recommend people to have the same name of the interface as for the component as a good default.
- adding e.g. 'interface.v2' could be a way to not break code (not change what the interface provide).
- examples of what environments are used for:
  - build a library out of it.
  - build a stand alone command line tool out of it.
  - build a service (lambda, REST...) out of it.
- a section on how to rename and delete things.
-

Differences compared to lein-polylith
=====================================
  (split up in major and minor changes)
- parameters to commands are named.
- no support for empty top namespace.
- when you create a component, it will not include any example code in the test.
- git needs to be used, otherwise it can not determine what has changed since the last commit.
- builds on top of tools.deps instead of leiningen
  - provides a powerful ways to run tools an build your system.
- the interface can configured to have another name thant "interface".
- support for type hints as part of the function signature of functions.
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- simpler and less magic:
  - you work with the project from the root and have access to all environments and bricks.
  - no symbolic links
  - only environments, not both services and environments as in lein-polylith.
  - no support for empty workspace interfaces (which is discouraged anyway).
  - change management is handled by git and calculated based on HEAD (latest commit),
    not by both git and via file timestamps.
- support for more than one environment and to select what src, test and resource
  directories that should be included in each environment.
- improved error messages.
- an environment can have a different version of a library than other environments.
- improved testing experience:
  - the ouput from the tests are shown and no compilation of the bricks are performed +
  - the tests run faster in separate class loaders.
  - a failing test stops the execution immediately.
  - tests can be added to the environment level.
- the 'deps' command is improved except that it doesn't support showing function dependencies at the moment.
- different commands:
  - no 'add', 'remove' or 'delete' commands, they can easily be done manually.
  - no 'changes' command. It is included in the 'info' command.
  - no 'build' command. This is handled through clj or other tools.
  - no settings command. The settings are in the root deps.edn and .polylith/config.edn.
  - no 'sync' command. Missing components or libraries will be shown as warnings.
  - new 'check' command.
  - no need for a 'prompt' command.
  - improved 'info' and 'deps' commands.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

Commands
========
./make-uberjar.sh dev polylith.clj.core.cli.poly
sudo cp ./environments/core/target/core.jar /usr/local/polylith/poly.jar

polylith:  clj -A:dev:test
realworld: clj -A:polylith:test

- mount
