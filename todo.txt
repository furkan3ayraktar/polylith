
- pimp components with :contract?.

- validate polylith map:
  - check if more than one component implements the same interface and if they mismatch.
    - determine which components are the contract.

- calculate changes
  - run the 'git diff' command:
    - if no arguments, use HEAD.
    - if one argument, diff against local changes
    - if two arguments, diff against the two hashes.
  - read all :require statements
  - calculate dependencies (to 'component/interface' namespace).

- use sorted set for interface-names + remove explicit set commands.

- support both .clj and .cljc files.

- use only the prefix :env and :env.test in profiles, stop using :service
  and :service.test as now. :env.test would be test environments.
  Also support :env.prod and averything that starts with ":env.".

- check that we handle all corner cases when reading code (check lein-polylith).

- make sure we can compile the code into a command line tool using GraalVM.

- replace \ with / at the entry point:
  (str/replace top-ns #"\." "/")

- to support other languages, each parameter also needs so handle the type.

- eventually: create a migration tool that migrates lein-polylith projects to
  polylith projects.

Questions
=========
- if each component has its environment, then we could calculate the list of
  libraries that is needed for each environment.
- If more than one component share the same interface, one of them will serve as
  interface. If one of them has the same name as the interface, it will be that
  component. If there is only one component with that interface, it will be that
  component. If two or more components share the same interface but none of them
  has the same name as the interface, then these components should be defined
  in the {:polylith :components} key, e.g.:
    :components {article {:interface? true
                          :libraries [clj-jwt crypto-password]}}}

Doc
===
- example of how to add macros in the interface.


Differences compared to lein-polylith
=====================================
- each service can have its own version of a library, so that service A has
  version 1.1 of a library, but service B has 1.2 and the development
  environment has 1.3.


