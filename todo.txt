
- handle :name, :type and :parameters as strings in definitions.
- store imports as strings.

- change from "Missing data definition" to "Missing definition"
- add 'lib-imports' to components that is the set of all imports, except components.


- add :ns interface to each interface definition.
  - make sub namespaces to 'interface' be bart of the contract, e.g. interface.spec.

- calculate changes
  - run the 'git diff' command:
    - if no arguments, use HEAD.
    - if one argument, diff against local changes
    - if two arguments, diff against the two hashes.
  - read all :require statements
  - calculate dependencies (to 'component/interface' namespace).

- check that we handle all corner cases when reading code (check lein-polylith).

- make sure we can compile the code into a command line tool using GraalVM.

- check if support for .cljs files make sense.

Questions
=========
- how do we run all the tests using deps?
- support both edn and JSON as output, with configuration?

Leave for now
=============
- should the name of a command line tool be 'poly'?
- how to handle test dependencies?
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.

Doc
===
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- a function can't be used as an implememtor of a macro in two different components
  and vice versa.

Differences compared to lein-polylith
=====================================
- each service can have its own version of a library, so that service A has
  version 1.1 of a library, but service B has 1.2 and the development
  environment has 1.3.

Design decisions
================
- To be able to reload a whole comonent in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of function in the namespace.
