
- make sure everything in the workspace is stored as strings.

- remove :deps on the :workspace root. It is added to each :env anyway.
  - double check, maybe it's done in workspace.
- remove :paths on the :workspace root. It is added to each :env anyway.

- refactor the 'test' command.
- get 'compile' to work.

- store :deps as strings (and not symbols) but remember to convert them back to
  symbols before use.



- move things from 'shared' to 'common' and delete 'shared'.
- calculate what environments that has changed.
- make sure we can compile the code into a command line tool using GraalVM.
- compile a 'poly' tool with GraalVM.
- activate the 'oldstuff' code, create basees.

- also store sha1 and sha2 in the result from changes.



- commands:
  - verify:
    - prints the messages
  - ws
  - change
    -
  - test
    -
  - build
    - build a simple jar

- store extra information for each warning/error (e.g.):
  {:interface "payment"
   :component "payment"
   :definition {:name "pay", :type "function", :parameters ["a"] :sub-ns ""}
  }

- poly
  - parameters:
    -output json
      - could also be set in the project workspace or under ~/.polylith.
    -since sha



Questions
=========
- figure out a way to show the output while running the tests.
- should we discard :type because it's not used by our code and can
  be resolved via where it is stored in the map (:bases, :components)?
  If not, then we need to add it to environments also.

Leave for now
=============
- release the new tool + make it the default in the realworld repository +
  create a branch for the old lein-polylith code.
- create a githook that verifies the project.
- should the name of a command line tool be 'poly'?
- how to handle test dependencies?
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- how to decorate the errors and warnings so that a tool can easily mark what's
  wrong in a e.g. a UI.


Doc
===
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- If using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.

Differences compared to lein-polylith
=====================================
- it is much faster.
- the new tool is simpler and you can e.g. add, rename and delete components manually
  without extra tooling.
- each service can have its own version of a library, so that service A has
  version 1.1 of a library, but service B has 1.2 and the development
  environment has 1.3.
- we base changes on git, not on both git and timestamps.

Design decisions
================
- To be able to reload a whole comonent in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of function in the namespace.
