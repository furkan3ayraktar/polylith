
- dependencies must be calculated *after* all components have been read from disk,
  and operate on all interfaces, which are known only after everything have been scanned.

- extract out the check for not depending on anything else than interfaces.

- change component name from 'file' to 'disk'?

- validate polylith map:
  - check for illegal imports.
  - check for circular dependencies.
  - check that components and bases don't share the same name.
  - check if more than one component implements the same interface and if they mismatch.

- calculate changes
  - run the 'git diff' command:
    - if no arguments, use HEAD.
    - if one argument, diff against local changes
    - if two arguments, diff against the two hashes.
  - read all :require statements
  - calculate dependencies (to 'component/interface' namespace).

- check that we handle all corner cases when reading code (check lein-polylith).

- make sure we can compile the code into command line tool using GraalVM.

- replace \ with / at the entry point:
  (str/replace top-ns #"\." "/")

- add :allow-non-interface-dependency-to-component-from-base in :polylith.

- when not needed anymore, remove cmd.compile and cmd.test + :aliases.

- to support other languages, each parameter also needs so handle the type.

Questions
=========
- maybe we could support different languages in this way:
  - parse the code as it is
  - have a "transcribe-map" that tells what keywords are functions and who are just data.
    - this will allow us to show the real name of e.g. functions in visualisation tools
      and at the same time show functions and data in different way, e.g. in different colors.

Doc
===
- example of how to add macros in the interface.
