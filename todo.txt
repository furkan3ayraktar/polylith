
- base the calculations of circular dependencies on interface dependencies.

- validate workspace:
  - check for unimplemented interfaces.

- add tests.

- calculate changes
  - run the 'git diff' command:
    - if no arguments, use HEAD.
    - if one argument, diff against local changes
    - if two arguments, diff against the two hashes.
  - read all :require statements
  - calculate dependencies (to 'component/interface' namespace).

- use sorted set for interface-names + remove explicit set commands.

- support both .clj and .cljc files.

- use only the prefix :env and :env.test in profiles, stop using :service
  and :service.test as now. :env.test would be test environments.
  Also support :env.prod and averything that starts with ":env.".

- check that we handle all corner cases when reading code (check lein-polylith).

- make sure we can compile the code into a command line tool using GraalVM.

- replace \ with / at the entry point:
  (str/replace top-ns #"\." "/")

- to support other languages, each parameter also needs so handle the type.

- eventually: create a migration tool that migrates lein-polylith projects to
  polylith projects.

Questions
=========
- store the environment definitions of :aliases as :environments?
  - store the reset of the aliases as something generic?
- only functions in interface.clj is part of the contract, but we allow dependencies
  to e.g. interface.spec which will show up as a dependency.

Doc
===
- example of how to add macros in the interface.


Differences compared to lein-polylith
=====================================
- each service can have its own version of a library, so that service A has
  version 1.1 of a library, but service B has 1.2 and the development
  environment has 1.3.

Design decisions
================
- To be able to reload a whole comonent in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of function in the namespace.
