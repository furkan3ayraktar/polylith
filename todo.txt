
- change color-mode from plain to none.

- if an environment misses a component, show it correctly in the 'ws' command.

- check how 'ws' handles circular dependencies.

- put back the 'spec' component and make sure we have the :polylith section with
  an entry for :top-namespace + if color-mode is specifiec that it has valid values.

- make sure we don't throw exception if we type a command from a
  directory that has no deps.edn.

- have a look at the kotlin embedded library again.

- create a githook that verifies the project.

- change top namespace from 'polylith' to 'polylith.core' so that we
  can distinguish it from e.g. 'polylith.kotlin'.

- check that we follow symbolic links in file/paths-recursively.

- add the LICENSE to the root.

- only include the corresponding test-environment if the :aliases {:test ...}}
  key is defined in deps.edn.

- make sure we handle imported namespaces in a generic way, right now we assume
  that they are separated with a "." in deps.dependencies/brick-namespace.

- just add more attributes to what e.g. workspace-clj adds, so that
  a tool creator can decide to add whatever attributes they need
  to perform the 'test' and 'build' commands.

- add the version command.

- add tasks (arguments to the 'poly' command)':
  - ws
    - view the workspace map.
    - support returning JSON.
      - configured in deps.edn
      - stored in a config file in ~/.polylith
    - possibility to send in sha1 and sha2 or only sha1.
  - build
    - build a simple jar

- only run tests that has changed (directly or indirectly).
  {:changes {:changed-bricks []
             :changed-environments []}
             :changed-bricks-indirectly []
             :changed-environments-indirectly []}}}

Questions
=========
- change top namespace from 'polylith' to 'polylith.core'.
- polylith.workspace-clj.namespaces-from-disk/->namespace
- check if we should register for https://github.com/sponsors.

Leave for now
=============
- extract the doc for each function (metadata).
- release the new tool + make it the default in the realworld repository +
  create a branch for the old lein-polylith code.
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- figure out what jar:s are missing based on the imports.
- if building a UI, then we need to calculate this data based on :interface-deps:
  - uses-directly (interface + component per environment)
  - uses-indirectly
  - used-by-directly
  - used-by-indirectly
- in the UI, show the missing interface dependencies as interfaces
  in the environment column that contains the components.
- in the UI, when you click on a component or base, show what components
  it uses (directly or indirectly) in every environement + what components
  that uses it (directly or indirectly). If both thing happens at the same time,
  then we have circular dependencies!
- make sure we can compile the code into a command line tool using GraalVM.



Doc
===
- people sometimes ask for sub-components, but in polylith you instead divide
  your component in namespaces and sub namespaces to achieve the same thing.
- tips on how to do destructuring in the interface.
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.
- some extra benefits of using interfaces:
  - in the implementing namespace(s) the functions must be defined in the
    right order, but in the interface they can e.g. be listed in alphabetic order.
  - in the implementing namespace(s) the arguments can sometimes be destructured
    directly so that it's not obvious what "type" (map) it is, but in the interface
    we can keep a good name of each argument.
  - functions can be overloaded in the interface but have just one function
    signature in the implementing namespace where arguments can be nil.

Differences compared to lein-polylith
=====================================
- when people starts to build tooling for polylith, they could include
  components from this project as git source dependencies into their own
  projects and use e.g. the workspace-clj, workspace and common components!
  from each interface, which is the set of all dependencies from the components
  that implements that interface.
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- it is much faster.
- the new tool is simpler and you can e.g. add, rename and delete components manually
  without extra tooling.
- each service can have its own version of a library, so that service A has version 1.1
  of a library, but service B has 1.2 and the development environment has 1.3.
  In lein-polylith, all libraries had to have the same version in all
  services and develop environments.
- we base changes on git, not on both git and timestamps. The reason is to make it
  simpler and that timestamps didn't work well with git.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

Commands
========
./make-uberjar.sh core polylith.cli.poly
sudo cp ./environments/core/target/core.jar /usr/local/polylith/poly.jar

polylith:  clj -A:dev:test
realworld: clj -A:polylith:test
