
- validate polylith map:
  - checks if more than one component implements the same interface and if they mismatch.
  - checks if a component depends on a namespace other than interface (and not itself).
  - check for circular dependencies
  - check that components and bases don't share the same name.

- calculate changes
  - run the 'git diff' command:
    - if no arguments, use HEAD.
    - if one argument, diff against local changes
    - if two arguments, diff against thowe two hashes.
  - read all :require statements
  - calculate dependencies (to 'component/interface' namespace).

- the polylith map:
  {:polylith {:top-namespace ""}}
   :components [{:type :component
                  :name "x"
                  :interface {:name "x"
                  :declarations [{:type defn
                                  :name compile
                                  :overloads [:args [arg1 arg2]
                                  :arity 3]
                  :imports ["..."]
                  :dependencies ["component1" "base1"]
    :bases [{:type :base
             :name "x"}]
    :messages {:errors [""]
               :warnings [""]}

- check that we handle all corner cases when reading code (check lein-polylith).

- add support for defmacro in interfaces.

- when not needed anymore, remove cmd.compile and cmd.test.

- make sure we can compile the code into command line tool using GraalVM.

Questions
=========
- maybe we could support different languages in this way:
  - parse the code as it is
  - have a "transcribe-map" that tells what keywords are functions and who are just data.
    - this will allow us to show the real name of e.g. functions in visualisation tools
      and at the same time show functions and data in different way, e.g. in different colors.
