
- only include the corresponding test-environment if the :aliases {:test ...}}
  key is defined in deps.edn.

- figure out what components and interfaces that are used:
  - uses-directly (interface + component per environment)
  - uses-indirectly
  - used-by-directly
  - used-by-indirectly

- in the UI, show the missing interface dependencies as interfaces
  in the environment column that contains the components.

- change the validation 107 and base it on uses-directly and uses-indirectly.


- in the UI, when you click on a component or base, show what components
  it uses (directly or indirectly) in every environement + what components
  that uses it (directly or indirectly). If both thing happens at the same time,
  then we have circular dependencies!

- add error if deps.edn can't be read or parsed.

- check that components has a top namespace and an interface.

- add the version command.

- remove :implementing-interface-deps.

- calculate :lines-of-code-src and :lines-of-code-test on the root of the project
  that is the sum of loc for all components and bases.

- just add more attributes to what e.g. workspace-clj adds, so that
  a tool creator can decide to add whatever attributes they need
  to perform the 'test' and 'build' commands.

- show warning if depending on an interface namespace but it's not
  a known interface.

- change keys in changes to :changed-components...
- send in git diff to 'change'.

- add support for Kotlin.

- make sure we can compile the code into a command line tool using GraalVM.
- compile a 'poly' tool with GraalVM.

- add tasks (arguments to the 'poly' command)':
  - verify:
    - prints the warnings and errors.
  - ws
    - view the workspace map.
    - support returning JSON.
      - configured in deps.edn
      - stored in a config file in ~/.polylith
    - possibility to send in sha1 and sha2 or only sha1.
  - build
    - build a simple jar

- add error for the case where a namespace can't even be parsed.

- handle the case where a component doesn't exist any more in the 'diff'
  function, which especially can happen when sending in two SHA:s.

- check that we follow symbolic links in file/paths-recursively.

- store the types for each parameter in :parameters (of other than Object)
  so that we can support typed languages.

- add support to add an environment as a development environment in the :polylith map.
  Then it can be marked in orange in the UI.

- only run tests that has changed (directly or indirectly).
  {:changes {:bricks []
             :environments []}
             :bricks-indirect []
             :environments-indirect []}}}

- add the LICENSE to the root.


Questions
=========
- remove the build-tools base from the real-world example app.
- check if we should register for https://github.com/sponsors.
- move out workspace-clj + test-runner to its own repository, polylith-deps?
  - it may be harder to work with because we lose some of the benefits
    we have to work with a polylith workspace.
  - the good thing is that we will be more consistent with the tooling
    around polylith, so that we e.g. could create these repositories:
    - polylith-clojure-deps
    - polylith-clojure-lein
    - polylith-clojure-boot
    - polylith-kotlin-gradle-dsl
    - (should the repositories start with poly- instead, to show that we mean
      the cli tooling?
    - store these repositories under the new company name.


Leave for now
=============
- extract the doc for each function (metadata).
- release the new tool + make it the default in the realworld repository +
  create a branch for the old lein-polylith code.
- create a githook that verifies the project.
- should the name of a command line tool be 'poly'?
- how to handle test dependencies?
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- how to decorate the errors and warnings so that a tool can easily mark what's
  wrong in a e.g. a UI.
- figure out what jar:s are missing based on the imports.


Doc
===
- tips on how to do destructuring in the interface.
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.

Differences compared to lein-polylith
=====================================
- when people starts to build tooling for polylith, they could include
  components from this project as git source dependencies into their own
  projects and use e.g. the workspace-clj, workspace and common components!
  from each interface, which is the set of all dependencies from the components
  that implements that interface.
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- it is much faster.
- the new tool is simpler and you can e.g. add, rename and delete components manually
  without extra tooling.
- each service can have its own version of a library, so that service A has version 1.1
  of a library, but service B has 1.2 and the development environment has 1.3.
  In lein-polylith, all libraries had to have the same version in all
  services and develop environments.
- we base changes on git, not on both git and timestamps. The reason is to make it
  simpler and that timestamps didn't work well with git.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

----------------------------------------

workspace:
  polylith

environments:
  c = core

interfaces     bricks         loc (t)   c
-----------------------------------------
change         change          80  25   x
common         common         161   0   x
deps           deps            67 135   x
file           file            74   0   x
git            git             31  17   x
shell          shell           19   0   x
spec           spec            17   0   x
test-runner    test-runner     72   0   x
util           util            56  43   x
validate       validate       370 693   x
workspace      workspace      265  77   x
workspace-clj  workspace-clj  277 184   x
-              cli             82   0   x

total loc: 1570 (1174)


workspace:
  clojure-polylith-realworld-example-app

environments:
  h = helpers
  rb = realworld-backend

interfaces   bricks       loc (t)   h  rb
-----------------------------------------
article      article      332 554   -  x
build-tools  build-tools   42   0   x  -
comment      comment      116 159   -  x
database     database     146   0   -  x
log          log          106   0   -  x
profile      profile       79 164   -  x
spec         spec          68   0   -  x
tag          tag           16  30   -  x
user         user         189 170   -  x
-            helpers       16   0   x  -
-			 rest-api     318 449   -  x

total loc: 3180 (1526)

----------------------------------------

Commands
========
./make-uberjar.sh core polylith.cli.poly
sudo cp ./environments/core/target/core.jar /usr/local/polylith/poly.jar
