
- calculate changes
  - run the 'git diff' command:
    - if no arguments, use HEAD.
    - if one argument, diff against local changes
    - if two arguments, diff against the two hashes.
  - read all :require statements
  - calculate dependencies (to 'component/interface' namespace).

- check that we handle all corner cases when reading code (check lein-polylith).

- make sure we can compile the code into a command line tool using GraalVM.

- store the following information for each warning/error (e.g.):
  {:interface "pyment"
   :component "payment"
   :definition {:name "pay", :type "function", :parameters ["a"] :sub-ns ""}
  }


Questions
=========
- how to decorate the errors and warnings so that a tool can easily mark what's
  wrong in a e.g. a UI.
- how do we run all the tests using deps?
- support both edn and JSON as output, with configuration?

Leave for now
=============
- create a githook that verifies the project.
- should the name of a command line tool be 'poly'?
- how to handle test dependencies?
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.

Doc
===
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- a function can't be used as an implememtor of a macro in two different components
  and vice versa.

Differences compared to lein-polylith
=====================================
- each service can have its own version of a library, so that service A has
  version 1.1 of a library, but service B has 1.2 and the development
  environment has 1.3.

Design decisions
================
- To be able to reload a whole comonent in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of function in the namespace.
