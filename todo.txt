
- remove '' in error messge "Illegal dependency on namespace..."

- check for missing bricks in an environment.

- store each message with its own attributes, e.g.:
  {:type "error"
   :code 101
   :message "Circular dependencies was found: article > profile > article"
   :bricks ["article" "profile"]

- make sure we can compile the code into a command line tool using GraalVM.
- compile a 'poly' tool with GraalVM.

- add tasks (arguments to the 'poly' command)':
  - verify:
    - prints the warnings and errors.
  - ws
    - view the workspace map.
    - support returning JSON.
      - configured in deps.edn
      - stored in a config file in ~/.polylith
    - possibility to send in sha1 and sha2 or only sha1.
  - build
    - build a simple jar


- add error for the case where a namespace can't even be parsed.

- handle the case where a component doesn't exist any more in the 'diff'
  function, which especially can happen when sending in two SHA:s.

- check that we follow symbolic links in file/paths-recursively.

- store the types for each parameter in :parameters (of other than Object)
  so that we can support typed languages.

Questions
=========
- should we only run the tests for affected components? If so, then we should maybe
  calculate changes something like this instead (+ parse what tests each component has):
  - calculate changes:
    {:changes {:bricks []
               :environments []}
               :bricks-indirect []
               :environments-indirect []}}}
- error if an environment has more than one component that shares the same interface.
- should we support references to other workspaces, so that we are allowed to
  add e.g. "../another-ws/components/some-component/src" to an environment?
  - then we could add the :ws-name attribute bricks so that they became unique,
    or something similar.
- how should we calculate workspace changes?
  - include test environments?
- figure out a way to show the output while running the tests.

Leave for now
=============
- extract the doc for each function (metadata).
- release the new tool + make it the default in the realworld repository +
  create a branch for the old lein-polylith code.
- create a githook that verifies the project.
- should the name of a command line tool be 'poly'?
- how to handle test dependencies?
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- how to decorate the errors and warnings so that a tool can easily mark what's
  wrong in a e.g. a UI.


Doc
===
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.

Differences compared to lein-polylith
=====================================
- when people starts to build tooling for polylith, they could include
  components from this project as git source dependencies into their own
  projects and use e.g. the workspace-clj, workspace and common components!
- the way we calculate circular dependencies. In lein-polylith, we check each
  environment separately, but here we only use :implementing-interface-deps
  from each interface, which is the set of all dependencies from the components
  that implements that interface.
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- it is much faster.
- the new tool is simpler and you can e.g. add, rename and delete components manually
  without extra tooling.
- each service can have its own version of a library, so that service A has version 1.1
  of a library, but service B has 1.2 and the development environment has 1.3.
  In lein-polylith, all libraries had to have the same version in all
  services and develop environments.
- we base changes on git, not on both git and timestamps. The reason is to make it
  simpler and that timestamps didn't work well with git.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

------------------------------------------------------

##### polylith #####

                 core
                 ==============
<change>         change
<common>         common
<deps>           deps
<file>           file
<git>            git
<shell>          shell
<spec>           spec
<test>           test
<util>           util
<validate>       validate
<workspace>      workspace
<workspace-clj>  workspace-clj
---------------  -------------
-                tool

##### clojure-polylith-realworld-example-app #####

            build-tools  realworld-backend
            ===========  =================
<article>                article
<comment>                comment
<database>               database
<log>                    log
<profile>                profile
<spec>                   spec
<tag>                    tag
<user>                   user
----------  -----------  -----------------
-           build-tools  build-tools
-			             rest-api
