
- clean away "../.." in the enhance workspace step.
  If the path starts with "test/", add "environments/${env}/" before it so
  that it can be executed by the tests.
  Show warning if any of the paths don't fulfill these requirements.
  Test that we can add a test for an environment.
  - update the environment-test.

- calculate :run-tests-for attribute to each environment. Right now we only base
  that list of bricks on what bricks that are included in the tests for that
  environment.

- workspace-clj > changes > workspace.

- calculate changes. For each component/base/environment store an attribute
  :change-status that can be one of three values: "unchanged"
  "directly-changed" and "indirectly-changed".
  Store the rest of the calculations in the key :changes at the root.
  Show a '*' or '(*)' after each brick in the 'info' command and after each
  environment in the environment table.
  Only include a brick in :run-tests-for if it's changed (directly or indirectly).

- show 'xx' on each environment row in the 'info' command where the first
  one is whether it's included in the environment and the second if any
  tests are included.

- make showing lines of code optional in the 'info' command. Add an attribute
  :show-lines-of-code to the settings that can be true or false.

- use :file-extensions from :src-reader.
- use :slash from :src-reader

- extract workspace-clj/namespace/top-src-dirs to its own 'namespace'
  component and expose it in the core API.

- create a spec that checks a workspace + expose it in the core API.

- when a workspace is enhanced, also set :vcs to "git".

- show aliases in a separate table in the 'info' command where we also calculate
  the number of tests we have per environment + if it has changed +
  if the environment has tests of its own (+ calculate that attribute):
    environment  alias  test  loc     (t)
    -------------------------------------
    cli          cli     -    1,810   980
    core         core    -    1,620     0
    dev *        dev     x    2,340 1,230

- make the thousand seperator be configurable, so that we can e.g. print out
  2340 as any of these (default is ""): 2340 2,340 2.340

- add validation that detects if no component was found for an interface.

- make sure we only have one interface defined per component.

- fix the error that occurres when having an invalid test src folder, e.g.
  "../../components/z-jocketest".

- if an environment misses a component, show it correctly in the 'info' command
  as a yellow "i" in each environment.

- check how 'info' handles circular dependencies.

- put back the 'spec' component and make sure we have the :polylith section with
  an entry for :top-namespace + if color-mode is specifiec that it has valid values.

- make sure we don't throw exception if we type a command from a
  directory that has no deps.edn.

- have a look at the kotlin embedded library again.

- create a githook that verifies the project.

- check that we follow symbolic links in file/paths-recursively.

- add the LICENSE to the root.

- only include the corresponding test-environment if the :aliases {:test ...}}
  key is defined in deps.edn.

- in the 'cli' environment, depend on the core jar instead of real components.
  - maybe we need two variants:
    - polylith-clj-core
    - polylith-clj-core-aot

- make sure we handle imported namespaces in a generic way, right now we assume
  that they are separated with a "." in deps.dependencies/brick-namespace.

- just add more attributes to what e.g. workspace-clj adds, so that
  a tool creator can decide to add whatever attributes they need
  to perform the 'test' and 'build' commands.

- think of a solution where we send in 'none' as color-mode instead of
  forcing us to calculate both colorized-message and message in the 'validate' component.

- add the 'version' command.

- add a 'deps' command that could show what components it uses
  and what bricks uses it in each environment.

- add tasks (arguments to the 'poly' command)':
  - ws
    - view the workspace map.
    - support returning JSON.
      - configured in deps.edn
      - stored in a config file in ~/.polylith
    - possibility to send in sha1 and sha2 or only sha1.
  - build
    - build a simple jar

- only run tests that has changed (directly or indirectly).
  {:changes {:changed-bricks []
             :changed-environments []}
             :changed-bricks-indirectly []
             :changed-environments-indirectly []}}}

Questions
=========
- can I delete .gradle from the project root?
- it's really great that integration tests can be put in each environment, but where
  to put system level end-to-end tests?
- how can we have a build that first builds polylith.clj.core and then builds
  polylith.core and deploys it to clojars?
- we don't get nice error messages when running tests through tools.deps, e.g when
  a namespace can't be imported or if a component is missing so it can't compile.
- :color-mode should be per developer, not per workspace. Put it in .polylith/config.edn?
- polylith.workspace-clj.namespaces-from-disk/->namespace
- check if we should register for https://github.com/sponsors.

Leave for now
=============
- extract the doc for each function (metadata).
- when releasing:
  - make sure we have all the documentation in place.
  - it would be good if the tool that can migrate old lein-polylith projects were in place.
  - update realworld repo, make it the default in the realworld repository.
  - update the documentation in lein-polylith and tell that we have a new brand
    tool that builds on top of tools.deps.
  - update the :ws-reader/:project-url to point to master
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- figure out what jar:s are missing based on the imports.
- if building a UI, then we need to calculate this data based on :interface-deps:
  - uses-directly (interface + component per environment)
  - uses-indirectly
  - used-by-directly
  - used-by-indirectly
- in the UI, show the missing interface dependencies as interfaces
  in the environment column that contains the components.
- in the UI, when you click on a component or base, show what components
  it uses (directly or indirectly) in every environement + what components
  that uses it (directly or indirectly). If both thing happens at the same time,
  then we have circular dependencies!
- make sure we can compile the code into a command line tool using GraalVM.



Doc
===
- people sometimes ask for sub-components, but in polylith you instead divide
  your component in namespaces and sub namespaces to achieve the same thing.
- tips on how to do destructuring in the interface.
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.
- some extra benefits of using interfaces:
  - in the implementing namespace(s) the functions must be defined in the
    right order, but in the interface they can e.g. be listed in alphabetic order.
  - in the implementing namespace(s) the arguments can sometimes be destructured
    directly so that it's not obvious what "type" (map) it is, but in the interface
    we can keep a good name of each argument.
  - functions can be overloaded in the interface but have just one function
    signature in the implementing namespace where arguments can be nil.
  - if we use destructuring in the implementation, we can keep the original names
    in the interface for increased readability (it can be easier to understand if the
    parameter is e.g. 'user' in the interface instead of a list of destructured values.

Differences compared to lein-polylith
=====================================
- we support type hints as part of the function signature of functions.
- when people starts to build tooling for polylith, they could include
  components from this project as git source dependencies into their own
  projects and use e.g. the workspace-clj, workspace and common components!
  from each interface, which is the set of all dependencies from the components
  that implements that interface.
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- it is much faster.
- the new tool is simpler and you can e.g. add, rename and delete components manually
  without extra tooling.
- each service can have its own version of a library, so that service A has version 1.1
  of a library, but service B has 1.2 and the development environment has 1.3.
  In lein-polylith, all libraries had to have the same version in all
  services and develop environments.
- we base changes on git, not on both git and timestamps. The reason is to make it
  simpler and that timestamps didn't work well with git.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

Commands
========
./make-uberjar.sh dev polylith.clj.core.cli.poly
sudo cp ./environments/core/target/core.jar /usr/local/polylith/poly.jar

polylith:  clj -A:dev:test
realworld: clj -A:polylith:test
