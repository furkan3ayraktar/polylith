
- calculate changed bases and components based on git diff.

- make sure we can compile the code into a command line tool using GraalVM.

- store extra information for each warning/error (e.g.):
  {:interface "payment"
   :component "payment"
   :definition {:name "pay", :type "function", :parameters ["a"] :sub-ns ""}
  }


Questions
=========
- how to decorate the errors and warnings so that a tool can easily mark what's
  wrong in a e.g. a UI.
- how do we run all the tests using deps?
- support both edn and JSON as output, with configuration?

Leave for now
=============
- create a githook that verifies the project.
- should the name of a command line tool be 'poly'?
- how to handle test dependencies?
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.

Doc
===
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- If using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.

Differences compared to lein-polylith
=====================================
- each service can have its own version of a library, so that service A has
  version 1.1 of a library, but service B has 1.2 and the development
  environment has 1.3.


Design decisions
================
- To be able to reload a whole comonent in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of function in the namespace.
