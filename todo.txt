
- make sure to include :aot when creating an environment.

- implement 'create c'.
- implement 'migrate' that migrates old lein-polylith projects.



- ensure Polylith works on Windows.

- update help for the 'deps' command.
- add help for the 'create w' command.

- let util.def-map handle attributes with namespace in it, e.g. [paths deps aliases mvn/repos]
  in environments-from-disk.

- let 'workspace' just assoc new attributes so that extra attributes that we don't know about
  will not dissappear.

- read the line-separator and put it as an attribute to the workspace.

- make the "w" and "e" argument be mandatory for the "help create" command, e.g. "help create w".

- 'help' should not be part of core.

- make sure the workspace table looks okay even without an environment.

- add the 'diff' command, which performs a git diff.

- move the functionality in 'info -dump' into its own 'dump' command
  - if sending in -json, return JSON instead of EDN.
  - store the export format in ~/.polylith/config.edn

- experiment with implementing a git hook that if the workspace is valid, saves a workspace.edn
  at the root of the project and commits it before every push. Then we could "animate" over the
  changes of the system over time. It's important to store a :schema-version attribute of the
  workspace, to keep track of schema changes.

- check why workspace-clj doesn't have any :definitions in its :interface.

- implement the 'diff' command that lists the changed files that is used to calculate changed bricks
  and systems.

- show a more user friendly error if deps.edn is missing at the root.
- show a better error if :color-mode is not set in deps.edn.

- fix the error that occurres when having an invalid test src folder, e.g.
  "../../components/z-jocketest".

- if an environment misses a component, show it correctly in the 'info' command
  as a yellow "i" in each environment.

- also show the columns '#ns' and 'loc/ns' in the 'info' command when sending in -loc as argument.

- verify that the tool works from Windows:
  - use :slash from :src-reader

- use :file-extensions from :src-reader.

- check if the 'cli' environment can depende on the core jar instead
  and remove all bricks except three of them.

- extract workspace-clj/namespace/top-src-dirs to its own 'namespace'
  component and expose it in the core API.

- create a spec that checks a workspace + expose it in the core API.

- put back the 'spec' component and make sure we have the :polylith section with
  an entry for :top-namespace + if color-mode is specifiec that it has valid values.

- make sure we don't throw exception if we type a command from a
  directory that has no deps.edn.

- check that we follow symbolic links in file/paths-recursively.

- in the 'cli' environment, depend on the core jar instead of real components.
  - maybe we need two variants:
    - polylith-clj-core
    - polylith-clj-core-aot

- show a warning if a resource (together with its 'src' or 'test' folder) is defined in
  one environment but not in another (that has the source folder).
  - warn if you put files directory on the root of recources.

- add support for reading files from git and maybe http url:s. One idea is to create a 'reader'
  component that can delegate to e.g. 'file-reader' and others.

- add the 'version' command.

- add the 'build' command that builds a simple jar.

- add support for 'create ws', 'create e', 'create c' and 'create b'.

- in the 'deps' command, when sending in '-lib', also show library dependencies, e.g.:
    library                       version  cli  core  dev
    -----------------------------------------------------
    org.clojure/clojure           1.10.1    x    x     x
    org.clojure/tools.deps.alpha  0.8.695   x    x     x

- use clojure.tools.namespace.parse to get the dependencies to other namespaces.

- add a warning if a component is added to an environment but not used.

Questions
=========
- about the scrital project:
  - has all sub projects different top namespace?
  - before, when "everyting worked" how was your project different from now?
- can I delete .gradle from the project root?
- it's really great that integration tests can be put in each environment, but where
  to put system level end-to-end tests?
- how can we have a build that first builds polylith.clj.core and then builds
  polylith.core and deploys it to clojars?
- we don't get nice error messages when running tests through tools.deps, e.g when
  a namespace can't be imported or if a component is missing so it can't compile.
- :color-mode should be per developer, not per workspace. Put it in .polylith/config.edn?
- polylith.workspace-clj.namespaces-from-disk/->namespace
- check if we should register for https://github.com/sponsors.

- have a dev directory with a 'src' directory and namespace where we can import a polylith.clj.core
  namespace that has a function that allows us to reload an environment to the REPL.


Leave for now
=============
- extract the doc for each function (metadata).
- when releasing:
  - make sure we have all the documentation in place.
  - update realworld repo, make it the default in the realworld repository.
  - update the documentation in lein-polylith and tell that we have a new brand
    tool that builds on top of tools.deps.
  - update the :ws-reader/:project-url to point to master
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- figure out what jar:s are missing based on the imports.
- if building a UI, then we need to calculate this data based on :interface-deps:
  - uses-directly (interface + component per environment)
  - uses-indirectly
  - used-by-directly
  - used-by-indirectly
- in the UI, show the missing interface dependencies as interfaces
  in the environment column that contains the components.
- in the UI, when you click on a component or base, show what components
  it uses (directly or indirectly) in every environement + what components
  that uses it (directly or indirectly). If both thing happens at the same time,
  then we have circular dependencies!
- make sure we can compile the code into a command line tool using GraalVM.
- add the feature "hide-succeeding-rows" to the text-table component that will show
  following lines as blank. Support having more than one column in a "group".
- make sure we handle imported namespaces in a generic way, right now we assume
  that they are separated with a "." in deps.dependencies/brick-namespace.
- show dependencies at the function level?

Doc
===
- a components increases cohesion so that we can put all the code, tests, resources
  and documentation for that piece of code into one place, which increases changeability.
- show the colors I use for best contrasts + mention borealis.
- people sometimes ask for sub-components, but in polylith you instead divide
  your component in namespaces and sub namespaces to achieve the same thing.
- you don't need another abstraction, like UML diagrams, to communicate your high
  level design, because in polylith the workspace *is* your high level design!
- tips on how to do destructuring in the interface.
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.
- some extra benefits of using interfaces:
  - the interface can keep the parameter name as is and only have destructuring in the implementation.
  - in the implementing namespace(s) the functions must be defined in the
    right order, but in the interface they can e.g. be listed in alphabetic order.
  - in the implementing namespace(s) the arguments can sometimes be destructured
    directly so that it's not obvious what "type" (map) it is, but in the interface
    we can keep a good name of each argument.
  - functions can be overloaded in the interface but have just one function
    signature in the implementing namespace where arguments can be nil.
  - if we use destructuring in the implementation, we can keep the original names
    in the interface for increased readability (it can be easier to understand if the
    parameter is e.g. 'user' in the interface instead of a list of destructured values.
  - refer to this code where we in a couple of places don't deletage to a core namespace
    and in another (validate) mostly delegate, but keep things in the interface.
- recommend people to have the same name of the interface as for the component as a good default.
- adding e.g. 'interface.v2' could be a way to not break code (not change what the interface provide).
- examples of what environments are used for:
  - use it as a development environment.
  - build a library out of it.
  - build a stand alone command line tool out of it.
  - build a service (lambda, REST...) out of it.

Differences compared to lein-polylith
=====================================
- you need to run git, otherwise it can not determine what has changed since the last commit.
- builds on top of tools.deps instead of leiningen.
- the interface can be named both 'interface' and 'inerfc' and have sub namespaces.
- support for type hints as part of the function signature of functions.
- easier to build libraries and toolings around polylith by using the polylith-core library.
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- simpler and less "intrusive":
  - you work with the project from the root and have access to all environments and bricks.
  - no symbolic links
  - only environments, not both services and environments as in lein-polylith.
  - no empty workspace interfaces.
  - code can easily be added manually and no need for 'create' and 'delete' commands.
  - changes are handled entirely by git, not by both git and via file timestamps.
  - no 'sync' command needed.
- more powerful:
  - supports multiple environments
  - supports having tests per environment.
  - faster. No need for a 'prompt' command. The 'check' command runs in around a second.
  - advanced 'info' and 'deps' commands with support for colors.
  - improved error messages.
  - an environment can have a different version of a library than other environments.
- improved testing experience. In lein-polylith all bricks were compiled and no test output was
  shown during test execution. Now the ouput from the tests are shown and no compilation of the
  bricks are performed + they run faster in separate class loaders.
- the 'deps' command is improved except that it doesn't support showing dependencies
  at the function level at the moment.
- you need to take care of what libraries you need per environment manually.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

Commands
========
./make-uberjar.sh dev polylith.clj.core.cli.poly
sudo cp ./environments/core/target/core.jar /usr/local/polylith/poly.jar

polylith:  clj -A:dev:test
realworld: clj -A:polylith:test
