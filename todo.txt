
- improve the 'ws' command:
  - print colors
  - print extra info
  - remove c/b
  - add row between components/bases
  - support for aliases
  - number aliases with 1,2,3...
  - if running 'poly ws -map', print out the whole map as today.



====================================================================

workspace:
  polylith

lines of code, src (test):
  1570 (1174)

environments:
  c = core

interface      c/b  brick          loc (t)   c
----------------------------------------------
change          c   change          80  25   x
common          c   common         161   0   x
deps            c   deps            67 135   x
file            c   file            74   0   x
git             c   git             31  17   x
shell           c   shell           19   0   x
spec            c   spec            17   0   x
test-runner     c   test-runner     72   0   x
util            c   util            56  43   x
validate        c   validate       370 693   x
workspace       c   workspace      265  77   x
workspace-clj   c   workspace-clj  277 184   x
-               b   cli             82   0   x

====================================================================

- create a githook that verifies the project.

- change top namespace from 'polylith' to 'polylith.core' so that we
  can distinguish it from e.g. 'polylith.kotlin'.

- check that we follow symbolic links in file/paths-recursively.

- add the LICENSE to the root.

- only include the corresponding test-environment if the :aliases {:test ...}}
  key is defined in deps.edn.

- make sure we handle imported namespaces in a generic way, right now we assume
  that they are separated with a "." in deps.dependencies/brick-namespace.

- just add more attributes to what e.g. workspace-clj adds, so that
  a tool creator can decide to add whatever attributes they need
  to perform the 'test' and 'build' commands.

- add the version command.

- add tasks (arguments to the 'poly' command)':
  - ws
    - view the workspace map.
    - support returning JSON.
      - configured in deps.edn
      - stored in a config file in ~/.polylith
    - possibility to send in sha1 and sha2 or only sha1.
  - build
    - build a simple jar

- only run tests that has changed (directly or indirectly).
  {:changes {:changed-bricks []
             :changed-environments []}
             :changed-bricks-indirectly []
             :changed-environments-indirectly []}}}

Questions
=========
- change top namespace from 'polylith' to 'polylith.core'.
- polylith.workspace-clj.namespaces-from-disk/->namespace
- check if we should register for https://github.com/sponsors.

Leave for now
=============
- extract the doc for each function (metadata).
- release the new tool + make it the default in the realworld repository +
  create a branch for the old lein-polylith code.
- create a migration tool that migrates lein-polylith projects to polylith projects.
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java.
- check if support for .cljs files make sense.
- figure out what jar:s are missing based on the imports.
- if building a UI, then we need to calculate this data based on :interface-deps:
  - uses-directly (interface + component per environment)
  - uses-indirectly
  - used-by-directly
  - used-by-indirectly
- in the UI, show the missing interface dependencies as interfaces
  in the environment column that contains the components.
- in the UI, when you click on a component or base, show what components
  it uses (directly or indirectly) in every environement + what components
  that uses it (directly or indirectly). If both thing happens at the same time,
  then we have circular dependencies!
- make sure we can compile the code into a command line tool using GraalVM.



Doc
===
- tips on how to do destructuring in the interface.
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it is has been replaced by this tool.

Differences compared to lein-polylith
=====================================
- when people starts to build tooling for polylith, they could include
  components from this project as git source dependencies into their own
  projects and use e.g. the workspace-clj, workspace and common components!
  from each interface, which is the set of all dependencies from the components
  that implements that interface.
- if a definition is defined as a 'defn' in one interface, it must be implemented
  as a function in all components for that interface (not mixing functions and macros)
  and the other way around.
- it is much faster.
- the new tool is simpler and you can e.g. add, rename and delete components manually
  without extra tooling.
- each service can have its own version of a library, so that service A has version 1.1
  of a library, but service B has 1.2 and the development environment has 1.3.
  In lein-polylith, all libraries had to have the same version in all
  services and develop environments.
- we base changes on git, not on both git and timestamps. The reason is to make it
  simpler and that timestamps didn't work well with git.

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

----------------------------------------

workspace:
  clojure-polylith-realworld-example-app

lines of code, src (test):
  3180 (1526)

environments:
  h = helpers
  rb = realworld-backend

interface    c/b  brick        loc (t)   h  rb
----------------------------------------------
article       c   article      332 554   -  x
build-tools   c   build-tools   42   0   x  -
comment       c   comment      116 159   -  x
database      c   database     146   0   -  x
log           c   log          106   0   -  x
profile       c   profile       79 164   -  x
spec          c   spec          68   0   -  x
tag           c   tag           16  30   -  x
user          c   user         189 170   -  x
-             b   helpers       16   0   x  -
-			  b   rest-api     318 449   -  x

----------------------------------------------

workspace:
  polylith

lines of code, src (test):
  1570 (1174)

environments:
  c = core

interface      c/b  brick          loc (t)   c
----------------------------------------------
change          c   change          80  25   x
common          c   common         161   0   x
deps            c   deps            67 135   x
file            c   file            74   0   x
git             c   git             31  17   x
shell           c   shell           19   0   x
spec            c   spec            17   0   x
test-runner     c   test-runner     72   0   x
util            c   util            56  43   x
validate        c   validate       370 693   x
workspace       c   workspace      265  77   x
workspace-clj   c   workspace-clj  277 184   x
-               b   cli             82   0   x




Commands
========
./make-uberjar.sh core polylith.cli.poly
sudo cp ./environments/core/target/core.jar /usr/local/polylith/poly.jar

polylith:  clj -A:dev:test
realworld: clj -A:polylith:test
