
- update the help.
  - create a good example and store each step with a tag in git.
  - have separate help for the different 'create' variants + show in the overview.

- let the output of 'ws' be nicely formatted and come in a logical order.

- add the 'version' command.
  - view home directory

- remove the two initial blank lines in the info command when no git repo.

- document the code more.

- check what happens if we add a dependency other than :mvn/version and if we
  could show those in the library dependency diagram.

- figure out how stable tags can interfere and maybe add support for user custom
  :stable-since-tag-pattern.


Furkan:
- update the documentation in the realworld-example.
- create a CircleCI job that can build the realworld-example.
- set up the polylith github project:
  - so that people can report errors
  - activate CI
- fix so that we can run the create tests from the REPL. The problem is in
  polylith.clj.core.creator.workspace/create, when copying logo.png.

Questions
=========
- what tool to use when building the homepage.
- check if we should register for https://github.com/sponsors.

When releasing
==============
- update the link in lein-polylith: https://github.com/tengstrand/polylith/tree/core

Leave for now
=============
- get colors to work in windows.
- let util.def-map handle attributes with namespace in it, e.g. [paths deps aliases mvn/repos]
  in environments-from-disk.
- also show the columns '#ns' and 'loc/ns' in the 'info' command when sending in -loc as argument.
- put back the 'spec' component and make sure we have the :polylith section with
  an entry for :top-namespace + if color-mode is specifiec that it has valid values.
  - create a spec that checks a workspace + expose it in the core API.
- add support for reading files from git and maybe http url:s. One idea is to create a 'reader'
  component that can delegate to e.g. 'file-reader' and others.
- maybe use clj-exec: https://insideclojure.org/2020/07/28/clj-exec/
- extract the doc for each function (metadata).
- when releasing:
  - make sure we have all the documentation in place.
  - update realworld repo, make it the default in the realworld repository.
  - update the documentation in lein-polylith and tell that we have a new brand
    tool that builds on top of tools.deps.
  - update the :ws-reader/:project-url to point to master
- html doc that automatically updates itself.
  - add support for extracting the APIs from a base, e.g. REST.
- add support for another language, e.g. Java and/or Kotlin.
  - let 'workspace' just assoc new attributes so that extra attributes that we don't know about
    will not dissappear.
- check if support for .cljs files make sense.
- figure out what jar:s are missing based on the imports.
- make sure we handle imported namespaces in a generic way, right now we assume
  that they are separated with a "." in deps.dependencies/brick-namespace.
- show dependencies at the function level?

Doc
===
- if giving both a env and a brick in 'deps' then if only the base is used as the "root"
  (has a main function) then the columns should match the the green rows, otherwise
  we have an isolated and probably not used component (if not used as configuration or
  only in tests or via reflection).
- link to lincense: https://opensource.org/licenses/eclipse-1.0.php
- when explaining the git hook, git commit --no-verify, can be used to skip the hook.
- cursive tip, when deps.edn can't be parsed, you have to fix it and add it manually again.
- a components increases cohesion so that we can put all the code, tests, resources
  and documentation for that piece of code into one place, which increases changeability.
- show the colors I use for best contrasts + mention borealis.
- people sometimes ask for sub-components, but in polylith you instead divide
  your component in namespaces and sub namespaces to achieve the same thing.
- you don't need another abstraction, like UML diagrams, to communicate your high
  level design, because in polylith the workspace *is* your high level design!
- tips on how to do destructuring in the interface.
- have an example of how people can build their own tooling around polylith!
- example of how to add macros in the interface, e.g. 'unless' in:
  - https://clojuredocs.org/clojure.core/defmacro
- if using a function in two components that implement the same interface,
  all definitions must be function. The same goes for macros.
- tips on how to delegate from interfaces:
  - use 'apply' if & in the parameter list, e.g.: (apply core/sh args)
  - use back tick for macros, e.g.: `(core/info ~args))
- you are allowed to access other namespaces than the interface from
  the 'test' directory. Only the code under the 'src' directory is checked
  to only access the 'interface' namespace.
- when we release the new version:
  - write a note on lein-polylith that it has been replaced by this tool.
- some extra benefits of using interfaces:
  - it's very clear what functions that can be accessed and setting things to private is
    not needed if delegating to implementing namespaces.
  - easier to test when functions in implementing namespaces can be kept public, because
    we already restrict access to other namespaces than the component interface.
  - the interface can keep the parameter name as is and only have destructuring in the implementation.
  - in the implementing namespace(s) the functions must be defined in the
    right order, but in the interface they can e.g. be listed in alphabetic order.
  - in the implementing namespace(s) the arguments can sometimes be destructured
    directly so that it's not obvious what "type" (map) it is, but in the interface
    we can keep a good name of each argument.
  - functions can be overloaded in the interface but have just one function
    signature in the implementing namespace where arguments can be nil.
  - if we use destructuring in the implementation, we can keep the original names
    in the interface for increased readability (it can be easier to understand if the
    parameter is e.g. 'user' in the interface instead of a list of destructured values.
  - refer to this code where we in a couple of places don't deletage to a core namespace
    and in another (validate) mostly delegate, but keep things in the interface.
- recommend people to have the same name of the interface as for the component as a good default.
- adding e.g. 'interface.v2' could be a way to not break code (not change what the interface provide).
- examples of what environments are used for:
  - build a library out of it.
  - build a stand alone command line tool out of it.
  - build a service (lambda, REST...) out of it.
- a section on how to rename and delete things.
- in the Windows section:
  - put poly.jar and poly.bat in e.g. "C:\Program Files\Polylith" and set poly.bat to:
      @echo off
      start /wait /b java -jar "C:\Program Files\Polylith\poly.jar" %*
  - install java + set JAVA_HOME
  - install git
    - git config --global user.email "my-email@gmail.com"
    - git config --global user.name "My Name"

Design decisions
================
- to be able to reload a whole component in the REPL, it's important that all functions
  in the interface are implemented, so that we don't get a mix of functions from
  two different components in the namespace.

polylith:  clj -A:dev:test
realworld: clj -A:polylith:test

- mount

Git hook
========
Add to .git/hook/commit-msg:
  #!/usr/bin/env bash

  exec /usr/bin/java -jar /usr/local/polylith/poly.jar check color-mode:none ws-dir:/Users/tengstrand/source/polylith

  if [[ $? -ne 0 ]] then
    exit 1
  fi


Example/doc:
- create an empty workspace
